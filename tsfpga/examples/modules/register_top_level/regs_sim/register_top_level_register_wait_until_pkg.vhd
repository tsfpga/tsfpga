-- -----------------------------------------------------------------------------
-- This file is automatically generated by hdl-registers version 6.2.1-dev2.
-- Code generator VhdlSimulationWaitUntilPackageGenerator version 1.0.0.
-- Generated 2024-12-30 14:53 from file regs_register_top_level.toml at commit a88ea51b9e82.
-- Register hash 5389169bfaee4103dfc57327d36576428cd8e774.
-- -----------------------------------------------------------------------------

library ieee;
use ieee.fixed_pkg.all;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library vunit_lib;
use vunit_lib.bus_master_pkg.bus_master_t;
use vunit_lib.bus_master_pkg.wait_until_read_equals;
use vunit_lib.com_types_pkg.max_timeout;
use vunit_lib.com_types_pkg.network_t;
use vunit_lib.string_ops.hex_image;

library common;
use common.addr_pkg.addr_t;
use common.addr_pkg.addr_width;

library reg_file;
use reg_file.reg_file_pkg.reg_t;
use reg_file.reg_operations_pkg.regs_bus_master;

use work.register_top_level_regs_pkg.all;
use work.register_top_level_register_record_pkg.all;


package register_top_level_register_wait_until_pkg is

  -- ---------------------------------------------------------------------------
  -- Wait until the 'config' register equals the given 'value'.
  -- Note that '-' can be used as a wildcard in 'value' since 'check_match' is 
  -- used to check for equality.
  procedure wait_until_register_top_level_config_equals(
    signal net : inout network_t;
    value : in reg_t;
    base_address : in addr_t := (others => '0');
    bus_handle : in bus_master_t := regs_bus_master;
    timeout : delay_length := max_timeout;
    message : string := ""
  );
  -- ---------------------------------------------------------------------------

  -- ---------------------------------------------------------------------------
  -- Wait until the 'status' register equals the given 'value'.
  -- Note that '-' can be used as a wildcard in 'value' since 'check_match' is 
  -- used to check for equality.
  procedure wait_until_register_top_level_status_equals(
    signal net : inout network_t;
    value : in reg_t;
    base_address : in addr_t := (others => '0');
    bus_handle : in bus_master_t := regs_bus_master;
    timeout : delay_length := max_timeout;
    message : string := ""
  );
  -- ---------------------------------------------------------------------------

  -- ---------------------------------------------------------------------------
  -- Wait until the 'irq_status' register equals the given 'value'.
  -- Note that '-' can be used as a wildcard in 'value' since 'check_match' is 
  -- used to check for equality.
  procedure wait_until_register_top_level_irq_status_equals(
    signal net : inout network_t;
    value : in reg_t;
    base_address : in addr_t := (others => '0');
    bus_handle : in bus_master_t := regs_bus_master;
    timeout : delay_length := max_timeout;
    message : string := ""
  );
  -- ---------------------------------------------------------------------------

  -- ---------------------------------------------------------------------------
  -- Wait until the 'irq_mask' register equals the given 'value'.
  -- Note that '-' can be used as a wildcard in 'value' since 'check_match' is 
  -- used to check for equality.
  procedure wait_until_register_top_level_irq_mask_equals(
    signal net : inout network_t;
    value : in reg_t;
    base_address : in addr_t := (others => '0');
    bus_handle : in bus_master_t := regs_bus_master;
    timeout : delay_length := max_timeout;
    message : string := ""
  );
  -- ---------------------------------------------------------------------------

  -- ---------------------------------------------------------------------------
  -- Wait until the 'registers' register within the 'registers' register array equals the given 'value'.
  procedure wait_until_register_top_level_registers_registers_equals(
    signal net : inout network_t;
    array_index : in register_top_level_registers_range;
    value : in register_top_level_registers_registers_t;
    base_address : in addr_t := (others => '0');
    bus_handle : in bus_master_t := regs_bus_master;
    timeout : delay_length := max_timeout;
    message : string := ""
  );

  -- Wait until the 'field' field in the 'registers' register within the 'registers' register array equals the given 'value'.
  procedure wait_until_register_top_level_registers_registers_field_equals(
    signal net : inout network_t;
    array_index : in register_top_level_registers_range;
    value : in register_top_level_registers_registers_field_t;
    base_address : in addr_t := (others => '0');
    bus_handle : in bus_master_t := regs_bus_master;
    timeout : delay_length := max_timeout;
    message : string := ""
  );
  -- ---------------------------------------------------------------------------

end package;

package body register_top_level_register_wait_until_pkg is

  -- ---------------------------------------------------------------------------
  -- Wait until the 'config' register equals the given 'value'.
  -- Note that '-' can be used as a wildcard in 'value' since 'check_match' is 
  -- used to check for equality.
  procedure wait_until_register_top_level_config_equals(
    signal net : inout network_t;
    value : in reg_t;
    base_address : in addr_t := (others => '0');
    bus_handle : in bus_master_t := regs_bus_master;
    timeout : delay_length := max_timeout;
    message : string := ""
  ) is
    constant reg_value : reg_t := value;

    constant reg_index : register_top_level_reg_range := register_top_level_config;
    constant reg_address : addr_t := base_address + to_unsigned(4 * reg_index, addr_width);

    constant register_array_message : string := "";
    function base_address_message return string is
    begin
      if base_address /= 0 then
        return " (at base address " & hex_image(std_logic_vector(base_address)) & ")";
      end if;

      return "";
    end function;
    constant base_message : string := (
      "Timeout while waiting for the 'config' register"
      & register_array_message
      & base_address_message
      & " to equal the given value: "
      & to_string(reg_value)
      & "."
    );
    function get_message return string is
    begin
      if message = "" then
        return base_message;
      end if;

      return base_message & " " & message & ".";
    end function;
  begin
    wait_until_read_equals(
      net => net,
      bus_handle => bus_handle,
      addr => std_ulogic_vector(reg_address),
      value => reg_value,
      timeout => timeout,
      msg => get_message
    );
  end procedure;
  -- ---------------------------------------------------------------------------

  -- ---------------------------------------------------------------------------
  -- Wait until the 'status' register equals the given 'value'.
  -- Note that '-' can be used as a wildcard in 'value' since 'check_match' is 
  -- used to check for equality.
  procedure wait_until_register_top_level_status_equals(
    signal net : inout network_t;
    value : in reg_t;
    base_address : in addr_t := (others => '0');
    bus_handle : in bus_master_t := regs_bus_master;
    timeout : delay_length := max_timeout;
    message : string := ""
  ) is
    constant reg_value : reg_t := value;

    constant reg_index : register_top_level_reg_range := register_top_level_status;
    constant reg_address : addr_t := base_address + to_unsigned(4 * reg_index, addr_width);

    constant register_array_message : string := "";
    function base_address_message return string is
    begin
      if base_address /= 0 then
        return " (at base address " & hex_image(std_logic_vector(base_address)) & ")";
      end if;

      return "";
    end function;
    constant base_message : string := (
      "Timeout while waiting for the 'status' register"
      & register_array_message
      & base_address_message
      & " to equal the given value: "
      & to_string(reg_value)
      & "."
    );
    function get_message return string is
    begin
      if message = "" then
        return base_message;
      end if;

      return base_message & " " & message & ".";
    end function;
  begin
    wait_until_read_equals(
      net => net,
      bus_handle => bus_handle,
      addr => std_ulogic_vector(reg_address),
      value => reg_value,
      timeout => timeout,
      msg => get_message
    );
  end procedure;
  -- ---------------------------------------------------------------------------

  -- ---------------------------------------------------------------------------
  -- Wait until the 'irq_status' register equals the given 'value'.
  -- Note that '-' can be used as a wildcard in 'value' since 'check_match' is 
  -- used to check for equality.
  procedure wait_until_register_top_level_irq_status_equals(
    signal net : inout network_t;
    value : in reg_t;
    base_address : in addr_t := (others => '0');
    bus_handle : in bus_master_t := regs_bus_master;
    timeout : delay_length := max_timeout;
    message : string := ""
  ) is
    constant reg_value : reg_t := value;

    constant reg_index : register_top_level_reg_range := register_top_level_irq_status;
    constant reg_address : addr_t := base_address + to_unsigned(4 * reg_index, addr_width);

    constant register_array_message : string := "";
    function base_address_message return string is
    begin
      if base_address /= 0 then
        return " (at base address " & hex_image(std_logic_vector(base_address)) & ")";
      end if;

      return "";
    end function;
    constant base_message : string := (
      "Timeout while waiting for the 'irq_status' register"
      & register_array_message
      & base_address_message
      & " to equal the given value: "
      & to_string(reg_value)
      & "."
    );
    function get_message return string is
    begin
      if message = "" then
        return base_message;
      end if;

      return base_message & " " & message & ".";
    end function;
  begin
    wait_until_read_equals(
      net => net,
      bus_handle => bus_handle,
      addr => std_ulogic_vector(reg_address),
      value => reg_value,
      timeout => timeout,
      msg => get_message
    );
  end procedure;
  -- ---------------------------------------------------------------------------

  -- ---------------------------------------------------------------------------
  -- Wait until the 'irq_mask' register equals the given 'value'.
  -- Note that '-' can be used as a wildcard in 'value' since 'check_match' is 
  -- used to check for equality.
  procedure wait_until_register_top_level_irq_mask_equals(
    signal net : inout network_t;
    value : in reg_t;
    base_address : in addr_t := (others => '0');
    bus_handle : in bus_master_t := regs_bus_master;
    timeout : delay_length := max_timeout;
    message : string := ""
  ) is
    constant reg_value : reg_t := value;

    constant reg_index : register_top_level_reg_range := register_top_level_irq_mask;
    constant reg_address : addr_t := base_address + to_unsigned(4 * reg_index, addr_width);

    constant register_array_message : string := "";
    function base_address_message return string is
    begin
      if base_address /= 0 then
        return " (at base address " & hex_image(std_logic_vector(base_address)) & ")";
      end if;

      return "";
    end function;
    constant base_message : string := (
      "Timeout while waiting for the 'irq_mask' register"
      & register_array_message
      & base_address_message
      & " to equal the given value: "
      & to_string(reg_value)
      & "."
    );
    function get_message return string is
    begin
      if message = "" then
        return base_message;
      end if;

      return base_message & " " & message & ".";
    end function;
  begin
    wait_until_read_equals(
      net => net,
      bus_handle => bus_handle,
      addr => std_ulogic_vector(reg_address),
      value => reg_value,
      timeout => timeout,
      msg => get_message
    );
  end procedure;
  -- ---------------------------------------------------------------------------

  -- ---------------------------------------------------------------------------
  -- Wait until the 'registers' register within the 'registers' register array equals the given 'value'.
  procedure wait_until_register_top_level_registers_registers_equals(
    signal net : inout network_t;
    array_index : in register_top_level_registers_range;
    value : in register_top_level_registers_registers_t;
    base_address : in addr_t := (others => '0');
    bus_handle : in bus_master_t := regs_bus_master;
    timeout : delay_length := max_timeout;
    message : string := ""
  ) is
    constant reg_value : reg_t := to_slv(value);

    constant reg_index : register_top_level_reg_range := register_top_level_registers_registers(array_index=>array_index);
    constant reg_address : addr_t := base_address + to_unsigned(4 * reg_index, addr_width);

    constant register_array_message : string := " within the 'registers[" & to_string(array_index) & "]' register array";
    function base_address_message return string is
    begin
      if base_address /= 0 then
        return " (at base address " & hex_image(std_logic_vector(base_address)) & ")";
      end if;

      return "";
    end function;
    constant base_message : string := (
      "Timeout while waiting for the 'registers' register"
      & register_array_message
      & base_address_message
      & " to equal the given value: "
      & to_string(reg_value)
      & "."
    );
    function get_message return string is
    begin
      if message = "" then
        return base_message;
      end if;

      return base_message & " " & message & ".";
    end function;
  begin
    wait_until_read_equals(
      net => net,
      bus_handle => bus_handle,
      addr => std_ulogic_vector(reg_address),
      value => reg_value,
      timeout => timeout,
      msg => get_message
    );
  end procedure;

  -- Wait until the 'field' field in the 'registers' register within the 'registers' register array equals the given 'value'.
  procedure wait_until_register_top_level_registers_registers_field_equals(
    signal net : inout network_t;
    array_index : in register_top_level_registers_range;
    value : in register_top_level_registers_registers_field_t;
    base_address : in addr_t := (others => '0');
    bus_handle : in bus_master_t := regs_bus_master;
    timeout : delay_length := max_timeout;
    message : string := ""
  ) is
    constant reg_value : reg_t := (
      register_top_level_registers_registers_field => std_ulogic_vector(value),
      others => '-'
    );

    constant reg_index : register_top_level_reg_range := register_top_level_registers_registers(array_index=>array_index);
    constant reg_address : addr_t := base_address + to_unsigned(4 * reg_index, addr_width);

    constant register_array_message : string := " within the 'registers[" & to_string(array_index) & "]' register array";
    function base_address_message return string is
    begin
      if base_address /= 0 then
        return " (at base address " & hex_image(std_logic_vector(base_address)) & ")";
      end if;

      return "";
    end function;
    constant base_message : string := (
      "Timeout while waiting for the 'field' field in the 'registers' register"
      & register_array_message
      & base_address_message
      & " to equal the given value: "
      & to_string(reg_value)
      & "."
    );
    function get_message return string is
    begin
      if message = "" then
        return base_message;
      end if;

      return base_message & " " & message & ".";
    end function;
  begin
    wait_until_read_equals(
      net => net,
      bus_handle => bus_handle,
      addr => std_ulogic_vector(reg_address),
      value => reg_value,
      timeout => timeout,
      msg => get_message
    );
  end procedure;
  -- ---------------------------------------------------------------------------

end package body;
